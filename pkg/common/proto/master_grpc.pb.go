// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: pkg/common/proto/master.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MasterService_GetClusterState_FullMethodName     = "/quidditch.master.MasterService/GetClusterState"
	MasterService_WatchClusterState_FullMethodName   = "/quidditch.master.MasterService/WatchClusterState"
	MasterService_CreateIndex_FullMethodName         = "/quidditch.master.MasterService/CreateIndex"
	MasterService_DeleteIndex_FullMethodName         = "/quidditch.master.MasterService/DeleteIndex"
	MasterService_UpdateIndexSettings_FullMethodName = "/quidditch.master.MasterService/UpdateIndexSettings"
	MasterService_GetIndexMetadata_FullMethodName    = "/quidditch.master.MasterService/GetIndexMetadata"
	MasterService_AllocateShard_FullMethodName       = "/quidditch.master.MasterService/AllocateShard"
	MasterService_RebalanceShards_FullMethodName     = "/quidditch.master.MasterService/RebalanceShards"
	MasterService_RegisterNode_FullMethodName        = "/quidditch.master.MasterService/RegisterNode"
	MasterService_UnregisterNode_FullMethodName      = "/quidditch.master.MasterService/UnregisterNode"
	MasterService_NodeHeartbeat_FullMethodName       = "/quidditch.master.MasterService/NodeHeartbeat"
)

// MasterServiceClient is the client API for MasterService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MasterService manages cluster state, shard allocation, and index metadata
type MasterServiceClient interface {
	// Cluster state management
	GetClusterState(ctx context.Context, in *GetClusterStateRequest, opts ...grpc.CallOption) (*ClusterStateResponse, error)
	WatchClusterState(ctx context.Context, in *WatchClusterStateRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ClusterStateEvent], error)
	// Index management
	CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error)
	DeleteIndex(ctx context.Context, in *DeleteIndexRequest, opts ...grpc.CallOption) (*DeleteIndexResponse, error)
	UpdateIndexSettings(ctx context.Context, in *UpdateIndexSettingsRequest, opts ...grpc.CallOption) (*UpdateIndexSettingsResponse, error)
	GetIndexMetadata(ctx context.Context, in *GetIndexMetadataRequest, opts ...grpc.CallOption) (*IndexMetadataResponse, error)
	// Shard allocation
	AllocateShard(ctx context.Context, in *AllocateShardRequest, opts ...grpc.CallOption) (*AllocateShardResponse, error)
	RebalanceShards(ctx context.Context, in *RebalanceShardsRequest, opts ...grpc.CallOption) (*RebalanceShardsResponse, error)
	// Node registration
	RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeResponse, error)
	UnregisterNode(ctx context.Context, in *UnregisterNodeRequest, opts ...grpc.CallOption) (*UnregisterNodeResponse, error)
	NodeHeartbeat(ctx context.Context, in *NodeHeartbeatRequest, opts ...grpc.CallOption) (*NodeHeartbeatResponse, error)
}

type masterServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMasterServiceClient(cc grpc.ClientConnInterface) MasterServiceClient {
	return &masterServiceClient{cc}
}

func (c *masterServiceClient) GetClusterState(ctx context.Context, in *GetClusterStateRequest, opts ...grpc.CallOption) (*ClusterStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterStateResponse)
	err := c.cc.Invoke(ctx, MasterService_GetClusterState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterServiceClient) WatchClusterState(ctx context.Context, in *WatchClusterStateRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ClusterStateEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MasterService_ServiceDesc.Streams[0], MasterService_WatchClusterState_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchClusterStateRequest, ClusterStateEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MasterService_WatchClusterStateClient = grpc.ServerStreamingClient[ClusterStateEvent]

func (c *masterServiceClient) CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateIndexResponse)
	err := c.cc.Invoke(ctx, MasterService_CreateIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterServiceClient) DeleteIndex(ctx context.Context, in *DeleteIndexRequest, opts ...grpc.CallOption) (*DeleteIndexResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteIndexResponse)
	err := c.cc.Invoke(ctx, MasterService_DeleteIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterServiceClient) UpdateIndexSettings(ctx context.Context, in *UpdateIndexSettingsRequest, opts ...grpc.CallOption) (*UpdateIndexSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateIndexSettingsResponse)
	err := c.cc.Invoke(ctx, MasterService_UpdateIndexSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterServiceClient) GetIndexMetadata(ctx context.Context, in *GetIndexMetadataRequest, opts ...grpc.CallOption) (*IndexMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IndexMetadataResponse)
	err := c.cc.Invoke(ctx, MasterService_GetIndexMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterServiceClient) AllocateShard(ctx context.Context, in *AllocateShardRequest, opts ...grpc.CallOption) (*AllocateShardResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AllocateShardResponse)
	err := c.cc.Invoke(ctx, MasterService_AllocateShard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterServiceClient) RebalanceShards(ctx context.Context, in *RebalanceShardsRequest, opts ...grpc.CallOption) (*RebalanceShardsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RebalanceShardsResponse)
	err := c.cc.Invoke(ctx, MasterService_RebalanceShards_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterServiceClient) RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterNodeResponse)
	err := c.cc.Invoke(ctx, MasterService_RegisterNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterServiceClient) UnregisterNode(ctx context.Context, in *UnregisterNodeRequest, opts ...grpc.CallOption) (*UnregisterNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnregisterNodeResponse)
	err := c.cc.Invoke(ctx, MasterService_UnregisterNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterServiceClient) NodeHeartbeat(ctx context.Context, in *NodeHeartbeatRequest, opts ...grpc.CallOption) (*NodeHeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeHeartbeatResponse)
	err := c.cc.Invoke(ctx, MasterService_NodeHeartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MasterServiceServer is the server API for MasterService service.
// All implementations must embed UnimplementedMasterServiceServer
// for forward compatibility.
//
// MasterService manages cluster state, shard allocation, and index metadata
type MasterServiceServer interface {
	// Cluster state management
	GetClusterState(context.Context, *GetClusterStateRequest) (*ClusterStateResponse, error)
	WatchClusterState(*WatchClusterStateRequest, grpc.ServerStreamingServer[ClusterStateEvent]) error
	// Index management
	CreateIndex(context.Context, *CreateIndexRequest) (*CreateIndexResponse, error)
	DeleteIndex(context.Context, *DeleteIndexRequest) (*DeleteIndexResponse, error)
	UpdateIndexSettings(context.Context, *UpdateIndexSettingsRequest) (*UpdateIndexSettingsResponse, error)
	GetIndexMetadata(context.Context, *GetIndexMetadataRequest) (*IndexMetadataResponse, error)
	// Shard allocation
	AllocateShard(context.Context, *AllocateShardRequest) (*AllocateShardResponse, error)
	RebalanceShards(context.Context, *RebalanceShardsRequest) (*RebalanceShardsResponse, error)
	// Node registration
	RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeResponse, error)
	UnregisterNode(context.Context, *UnregisterNodeRequest) (*UnregisterNodeResponse, error)
	NodeHeartbeat(context.Context, *NodeHeartbeatRequest) (*NodeHeartbeatResponse, error)
	mustEmbedUnimplementedMasterServiceServer()
}

// UnimplementedMasterServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMasterServiceServer struct{}

func (UnimplementedMasterServiceServer) GetClusterState(context.Context, *GetClusterStateRequest) (*ClusterStateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClusterState not implemented")
}
func (UnimplementedMasterServiceServer) WatchClusterState(*WatchClusterStateRequest, grpc.ServerStreamingServer[ClusterStateEvent]) error {
	return status.Error(codes.Unimplemented, "method WatchClusterState not implemented")
}
func (UnimplementedMasterServiceServer) CreateIndex(context.Context, *CreateIndexRequest) (*CreateIndexResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateIndex not implemented")
}
func (UnimplementedMasterServiceServer) DeleteIndex(context.Context, *DeleteIndexRequest) (*DeleteIndexResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteIndex not implemented")
}
func (UnimplementedMasterServiceServer) UpdateIndexSettings(context.Context, *UpdateIndexSettingsRequest) (*UpdateIndexSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateIndexSettings not implemented")
}
func (UnimplementedMasterServiceServer) GetIndexMetadata(context.Context, *GetIndexMetadataRequest) (*IndexMetadataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetIndexMetadata not implemented")
}
func (UnimplementedMasterServiceServer) AllocateShard(context.Context, *AllocateShardRequest) (*AllocateShardResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AllocateShard not implemented")
}
func (UnimplementedMasterServiceServer) RebalanceShards(context.Context, *RebalanceShardsRequest) (*RebalanceShardsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RebalanceShards not implemented")
}
func (UnimplementedMasterServiceServer) RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterNode not implemented")
}
func (UnimplementedMasterServiceServer) UnregisterNode(context.Context, *UnregisterNodeRequest) (*UnregisterNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UnregisterNode not implemented")
}
func (UnimplementedMasterServiceServer) NodeHeartbeat(context.Context, *NodeHeartbeatRequest) (*NodeHeartbeatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NodeHeartbeat not implemented")
}
func (UnimplementedMasterServiceServer) mustEmbedUnimplementedMasterServiceServer() {}
func (UnimplementedMasterServiceServer) testEmbeddedByValue()                       {}

// UnsafeMasterServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MasterServiceServer will
// result in compilation errors.
type UnsafeMasterServiceServer interface {
	mustEmbedUnimplementedMasterServiceServer()
}

func RegisterMasterServiceServer(s grpc.ServiceRegistrar, srv MasterServiceServer) {
	// If the following call panics, it indicates UnimplementedMasterServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MasterService_ServiceDesc, srv)
}

func _MasterService_GetClusterState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServiceServer).GetClusterState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MasterService_GetClusterState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServiceServer).GetClusterState(ctx, req.(*GetClusterStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MasterService_WatchClusterState_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchClusterStateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MasterServiceServer).WatchClusterState(m, &grpc.GenericServerStream[WatchClusterStateRequest, ClusterStateEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MasterService_WatchClusterStateServer = grpc.ServerStreamingServer[ClusterStateEvent]

func _MasterService_CreateIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServiceServer).CreateIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MasterService_CreateIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServiceServer).CreateIndex(ctx, req.(*CreateIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MasterService_DeleteIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServiceServer).DeleteIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MasterService_DeleteIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServiceServer).DeleteIndex(ctx, req.(*DeleteIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MasterService_UpdateIndexSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateIndexSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServiceServer).UpdateIndexSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MasterService_UpdateIndexSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServiceServer).UpdateIndexSettings(ctx, req.(*UpdateIndexSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MasterService_GetIndexMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIndexMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServiceServer).GetIndexMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MasterService_GetIndexMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServiceServer).GetIndexMetadata(ctx, req.(*GetIndexMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MasterService_AllocateShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocateShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServiceServer).AllocateShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MasterService_AllocateShard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServiceServer).AllocateShard(ctx, req.(*AllocateShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MasterService_RebalanceShards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebalanceShardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServiceServer).RebalanceShards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MasterService_RebalanceShards_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServiceServer).RebalanceShards(ctx, req.(*RebalanceShardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MasterService_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServiceServer).RegisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MasterService_RegisterNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServiceServer).RegisterNode(ctx, req.(*RegisterNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MasterService_UnregisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServiceServer).UnregisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MasterService_UnregisterNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServiceServer).UnregisterNode(ctx, req.(*UnregisterNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MasterService_NodeHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServiceServer).NodeHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MasterService_NodeHeartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServiceServer).NodeHeartbeat(ctx, req.(*NodeHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MasterService_ServiceDesc is the grpc.ServiceDesc for MasterService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MasterService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "quidditch.master.MasterService",
	HandlerType: (*MasterServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetClusterState",
			Handler:    _MasterService_GetClusterState_Handler,
		},
		{
			MethodName: "CreateIndex",
			Handler:    _MasterService_CreateIndex_Handler,
		},
		{
			MethodName: "DeleteIndex",
			Handler:    _MasterService_DeleteIndex_Handler,
		},
		{
			MethodName: "UpdateIndexSettings",
			Handler:    _MasterService_UpdateIndexSettings_Handler,
		},
		{
			MethodName: "GetIndexMetadata",
			Handler:    _MasterService_GetIndexMetadata_Handler,
		},
		{
			MethodName: "AllocateShard",
			Handler:    _MasterService_AllocateShard_Handler,
		},
		{
			MethodName: "RebalanceShards",
			Handler:    _MasterService_RebalanceShards_Handler,
		},
		{
			MethodName: "RegisterNode",
			Handler:    _MasterService_RegisterNode_Handler,
		},
		{
			MethodName: "UnregisterNode",
			Handler:    _MasterService_UnregisterNode_Handler,
		},
		{
			MethodName: "NodeHeartbeat",
			Handler:    _MasterService_NodeHeartbeat_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchClusterState",
			Handler:       _MasterService_WatchClusterState_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/common/proto/master.proto",
}
