
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>diagon: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/quidditch/quidditch/pkg/data/diagon/bridge.go (69.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package diagon

/*
#cgo CFLAGS: -I${SRCDIR}/c_api_src
#cgo LDFLAGS: -L${SRCDIR}/build -ldiagon -L${SRCDIR}/upstream/build/src/core -ldiagon_core -lz -lzstd -llz4 -Wl,-rpath,${SRCDIR}/upstream/build/src/core
#include &lt;stdlib.h&gt;
#include "diagon_c_api.h"
*/
import "C"

import (
        "encoding/json"
        "fmt"
        "sync"
        "unsafe"

        "go.uber.org/zap"
)

// DiagonBridge provides a Go interface to the real Diagon C++ search engine
type DiagonBridge struct {
        config     *Config
        logger     *zap.Logger
        shards     map[string]*Shard
        mu         sync.RWMutex
}

// Config holds Diagon configuration
type Config struct {
        DataDir     string
        SIMDEnabled bool
        Logger      *zap.Logger
}

// NewDiagonBridge creates a new Diagon bridge
func NewDiagonBridge(cfg *Config) (*DiagonBridge, error) <span class="cov1" title="3">{
        if cfg.Logger == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("logger is required")
        }</span>

        <span class="cov1" title="3">bridge := &amp;DiagonBridge{
                config: cfg,
                logger: cfg.Logger,
                shards: make(map[string]*Shard),
        }

        return bridge, nil</span>
}

// Start starts the Diagon engine
func (db *DiagonBridge) Start() error <span class="cov1" title="3">{
        db.logger.Info("Starting real Diagon C++ search engine",
                zap.String("data_dir", db.config.DataDir),
                zap.Bool("simd_enabled", db.config.SIMDEnabled))

        return nil
}</span>

// Stop stops the Diagon engine
func (db *DiagonBridge) Stop() error <span class="cov1" title="3">{
        db.logger.Info("Stopping Diagon engine")

        db.mu.Lock()
        defer db.mu.Unlock()

        // Close all shards
        for path, shard := range db.shards </span><span class="cov2" title="5">{
                db.logger.Info("Closing Diagon shard", zap.String("path", path))
                if err := shard.Close(); err != nil </span><span class="cov0" title="0">{
                        db.logger.Error("Error closing shard", zap.String("path", path), zap.Error(err))
                }</span>
        }

        <span class="cov1" title="3">return nil</span>
}

// CreateShard creates a new shard using real Diagon IndexWriter
func (db *DiagonBridge) CreateShard(path string) (*Shard, error) <span class="cov2" title="5">{
        db.mu.Lock()
        defer db.mu.Unlock()

        // Check if shard already exists
        if _, exists := db.shards[path]; exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("shard at path %s already exists", path)
        }</span>

        // Open directory
        <span class="cov2" title="5">cPath := C.CString(path)
        defer C.free(unsafe.Pointer(cPath))

        dir := C.diagon_open_mmap_directory(cPath) // Use MMapDirectory for performance
        if dir == nil </span><span class="cov0" title="0">{
                errMsg := C.GoString(C.diagon_last_error())
                return nil, fmt.Errorf("failed to open directory: %s", errMsg)
        }</span>

        // Create IndexWriter config
        <span class="cov2" title="5">config := C.diagon_create_index_writer_config()
        C.diagon_config_set_ram_buffer_size(config, 64.0)                   // 64MB buffer
        C.diagon_config_set_open_mode(config, 2)                            // CREATE_OR_APPEND
        C.diagon_config_set_commit_on_close(config, true)

        // Create IndexWriter
        writer := C.diagon_create_index_writer(dir, config)
        C.diagon_free_index_writer_config(config)

        if writer == nil </span><span class="cov0" title="0">{
                C.diagon_close_directory(dir)
                errMsg := C.GoString(C.diagon_last_error())
                return nil, fmt.Errorf("failed to create IndexWriter: %s", errMsg)
        }</span>

        <span class="cov2" title="5">shard := &amp;Shard{
                path:      path,
                bridge:    db,
                directory: dir,
                writer:    writer,
                reader:    nil, // Will be opened when needed
                logger:    db.logger.With(zap.String("shard_path", path)),
        }

        db.shards[path] = shard

        shard.logger.Info("Created real Diagon shard with IndexWriter")

        return shard, nil</span>
}

// GetShard retrieves an existing shard
func (db *DiagonBridge) GetShard(path string) (*Shard, error) <span class="cov0" title="0">{
        db.mu.RLock()
        defer db.mu.RUnlock()

        shard, exists := db.shards[path]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("shard at path %s not found", path)
        }</span>

        <span class="cov0" title="0">return shard, nil</span>
}

// Shard represents a real Diagon shard with IndexWriter/IndexReader
type Shard struct {
        path      string
        bridge    *DiagonBridge
        directory C.DiagonDirectory
        writer    C.DiagonIndexWriter
        reader    C.DiagonIndexReader
        searcher  C.DiagonIndexSearcher
        logger    *zap.Logger
        mu        sync.RWMutex
}

// IndexDocument indexes a document using real Diagon IndexWriter
func (s *Shard) IndexDocument(docID string, doc map[string]interface{}) error <span class="cov8" title="10006">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Create Diagon document
        diagonDoc := C.diagon_create_document()
        defer C.diagon_free_document(diagonDoc)

        // Add ID field (StringField - not analyzed, indexed)
        cDocID := C.CString(docID)
        defer C.free(unsafe.Pointer(cDocID))
        cIDFieldName := C.CString("_id")
        defer C.free(unsafe.Pointer(cIDFieldName))

        idField := C.diagon_create_string_field(cIDFieldName, cDocID)
        C.diagon_document_add_field(diagonDoc, idField)

        // Add other fields
        for key, value := range doc </span><span class="cov10" title="40018">{
                cFieldName := C.CString(key)
                defer C.free(unsafe.Pointer(cFieldName))

                switch v := value.(type) </span>{
                case string:<span class="cov9" title="30012">
                        // TextField for strings (analyzed, indexed, stored)
                        cValue := C.CString(v)
                        defer C.free(unsafe.Pointer(cValue))
                        field := C.diagon_create_text_field(cFieldName, cValue)
                        C.diagon_document_add_field(diagonDoc, field)</span>

                case int, int32, int64:<span class="cov8" title="10006">
                        // NumericDocValuesField for integers
                        val := int64(0)
                        switch n := v.(type) </span>{
                        case int:<span class="cov8" title="10006">
                                val = int64(n)</span>
                        case int32:<span class="cov0" title="0">
                                val = int64(n)</span>
                        case int64:<span class="cov0" title="0">
                                val = n</span>
                        }
                        <span class="cov8" title="10006">field := C.diagon_create_long_field(cFieldName, C.int64_t(val))
                        C.diagon_document_add_field(diagonDoc, field)</span>

                case float32, float64:<span class="cov0" title="0">
                        // NumericDocValuesField for floats (stored as int64 for now)
                        val := float64(0)
                        switch f := v.(type) </span>{
                        case float32:<span class="cov0" title="0">
                                val = float64(f)</span>
                        case float64:<span class="cov0" title="0">
                                val = f</span>
                        }
                        <span class="cov0" title="0">field := C.diagon_create_double_field(cFieldName, C.double(val))
                        C.diagon_document_add_field(diagonDoc, field)</span>

                default:<span class="cov0" title="0">
                        // Convert to JSON string for complex types
                        jsonBytes, err := json.Marshal(v)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn("Failed to marshal field, skipping",
                                        zap.String("field", key),
                                        zap.Error(err))
                                continue</span>
                        }
                        <span class="cov0" title="0">cValue := C.CString(string(jsonBytes))
                        defer C.free(unsafe.Pointer(cValue))
                        field := C.diagon_create_stored_field(cFieldName, cValue)
                        C.diagon_document_add_field(diagonDoc, field)</span>
                }
        }

        // Add document to IndexWriter
        <span class="cov8" title="10006">if !C.diagon_add_document(s.writer, diagonDoc) </span><span class="cov0" title="0">{
                errMsg := C.GoString(C.diagon_last_error())
                return fmt.Errorf("failed to add document: %s", errMsg)
        }</span>

        <span class="cov8" title="10006">s.logger.Debug("Indexed document via real Diagon IndexWriter",
                zap.String("doc_id", docID),
                zap.Int("fields", len(doc)))

        return nil</span>
}

// Commit commits all pending changes
func (s *Shard) Commit() error <span class="cov3" title="15">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if !C.diagon_commit(s.writer) </span><span class="cov0" title="0">{
                errMsg := C.GoString(C.diagon_last_error())
                return fmt.Errorf("commit failed: %s", errMsg)
        }</span>

        <span class="cov3" title="15">s.logger.Debug("Committed changes")
        return nil</span>
}

// Flush flushes buffered documents to disk
func (s *Shard) Flush() error <span class="cov1" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if !C.diagon_flush(s.writer) </span><span class="cov0" title="0">{
                errMsg := C.GoString(C.diagon_last_error())
                return fmt.Errorf("flush failed: %s", errMsg)
        }</span>

        <span class="cov1" title="1">s.logger.Debug("Flushed buffered documents")
        return nil</span>
}

// Refresh reopens the reader to see recent changes
func (s *Shard) Refresh() error <span class="cov1" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Commit first to ensure changes are visible
        if !C.diagon_commit(s.writer) </span><span class="cov0" title="0">{
                errMsg := C.GoString(C.diagon_last_error())
                return fmt.Errorf("commit failed during refresh: %s", errMsg)
        }</span>

        // Close old reader and searcher
        <span class="cov1" title="1">if s.searcher != nil </span><span class="cov1" title="1">{
                C.diagon_free_index_searcher(s.searcher)
                s.searcher = nil
        }</span>
        <span class="cov1" title="1">if s.reader != nil </span><span class="cov1" title="1">{
                C.diagon_close_index_reader(s.reader)
                s.reader = nil
        }</span>

        // Open new reader
        <span class="cov1" title="1">s.reader = C.diagon_open_index_reader(s.directory)
        if s.reader == nil </span><span class="cov0" title="0">{
                errMsg := C.GoString(C.diagon_last_error())
                return fmt.Errorf("failed to reopen reader: %s", errMsg)
        }</span>

        // Create new searcher
        <span class="cov1" title="1">s.searcher = C.diagon_create_index_searcher(s.reader)
        if s.searcher == nil </span><span class="cov0" title="0">{
                errMsg := C.GoString(C.diagon_last_error())
                return fmt.Errorf("failed to create searcher: %s", errMsg)
        }</span>

        <span class="cov1" title="1">s.logger.Debug("Refreshed shard (reopened reader)")
        return nil</span>
}

// Search executes a search query using real Diagon IndexSearcher
func (s *Shard) Search(query []byte, filterExpression []byte) (*SearchResult, error) <span class="cov3" title="11">{
        s.mu.Lock()

        // Ensure reader/searcher are initialized
        if s.reader == nil </span><span class="cov2" title="5">{
                // Open reader
                s.reader = C.diagon_open_index_reader(s.directory)
                if s.reader == nil </span><span class="cov0" title="0">{
                        s.mu.Unlock()
                        errMsg := C.GoString(C.diagon_last_error())
                        return nil, fmt.Errorf("failed to open reader: %s", errMsg)
                }</span>

                // Create searcher
                <span class="cov2" title="5">s.searcher = C.diagon_create_index_searcher(s.reader)
                if s.searcher == nil </span><span class="cov0" title="0">{
                        s.mu.Unlock()
                        errMsg := C.GoString(C.diagon_last_error())
                        return nil, fmt.Errorf("failed to create searcher: %s", errMsg)
                }</span>
        }

        <span class="cov3" title="11">s.mu.Unlock()

        // Parse query JSON to extract field and term
        // For now, support simple term queries: {"term": {"field": "value"}}
        var queryObj map[string]interface{}
        if err := json.Unmarshal(query, &amp;queryObj); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse query: %w", err)
        }</span>

        // Extract term query
        <span class="cov3" title="11">var diagonQuery C.DiagonQuery
        defer func() </span><span class="cov3" title="11">{
                if diagonQuery != nil </span><span class="cov3" title="11">{
                        C.diagon_free_query(diagonQuery)
                }</span>
        }()

        <span class="cov3" title="11">if termQuery, ok := queryObj["term"].(map[string]interface{}); ok </span><span class="cov3" title="11">{
                // {"term": {"field_name": "term_value"}}
                for field, value := range termQuery </span><span class="cov3" title="11">{
                        cField := C.CString(field)
                        defer C.free(unsafe.Pointer(cField))

                        cValue := C.CString(fmt.Sprintf("%v", value))
                        defer C.free(unsafe.Pointer(cValue))

                        term := C.diagon_create_term(cField, cValue)
                        defer C.diagon_free_term(term)

                        diagonQuery = C.diagon_create_term_query(term)
                        if diagonQuery == nil </span><span class="cov0" title="0">{
                                errMsg := C.GoString(C.diagon_last_error())
                                return nil, fmt.Errorf("failed to create term query: %s", errMsg)
                        }</span>
                        <span class="cov3" title="11">break</span> // Only support single term for now
                }
        } else<span class="cov0" title="0"> if _, ok := queryObj["match_all"]; ok </span><span class="cov0" title="0">{
                // Match all query - not yet implemented in Diagon Phase 4
                // Return empty results for now
                return &amp;SearchResult{
                        Took:      1,
                        TotalHits: 0,
                        MaxScore:  0.0,
                        Hits:      make([]*Hit, 0),
                }, nil
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("unsupported query type (only 'term' and 'match_all' supported)")
        }</span>

        // Execute search
        <span class="cov3" title="11">s.mu.RLock()
        topDocs := C.diagon_search(s.searcher, diagonQuery, 10)
        s.mu.RUnlock()

        if topDocs == nil </span><span class="cov0" title="0">{
                errMsg := C.GoString(C.diagon_last_error())
                return nil, fmt.Errorf("search failed: %s", errMsg)
        }</span>
        <span class="cov3" title="11">defer C.diagon_free_top_docs(topDocs)

        // Extract results
        totalHits := int64(C.diagon_top_docs_total_hits(topDocs))
        maxScore := float64(C.diagon_top_docs_max_score(topDocs))
        numResults := int(C.diagon_top_docs_score_docs_length(topDocs))

        hits := make([]*Hit, 0, numResults)
        for i := 0; i &lt; numResults; i++ </span><span class="cov4" title="50">{
                scoreDoc := C.diagon_top_docs_score_doc_at(topDocs, C.int(i))
                if scoreDoc == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="50">docID := int(C.diagon_score_doc_get_doc(scoreDoc))
                score := float64(C.diagon_score_doc_get_score(scoreDoc))

                // Note: Document retrieval (getting source) not yet implemented in Diagon Phase 4
                // Return doc ID and score only
                hits = append(hits, &amp;Hit{
                        ID:     fmt.Sprintf("doc_%d", docID),
                        Score:  score,
                        Source: map[string]interface{}{
                                "_internal_doc_id": docID,
                        },
                })</span>
        }

        <span class="cov3" title="11">result := &amp;SearchResult{
                Took:      5, // TODO: Track actual time
                TotalHits: totalHits,
                MaxScore:  maxScore,
                Hits:      hits,
        }

        s.logger.Debug("Executed search via real Diagon IndexSearcher",
                zap.Int64("total_hits", totalHits),
                zap.Float64("max_score", maxScore),
                zap.Int("num_results", numResults))

        return result, nil</span>
}

// GetDocument retrieves a document by ID
func (s *Shard) GetDocument(docID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Document retrieval not yet implemented in Diagon Phase 4
        // TODO: Implement when StoredFields reader is available
        return nil, fmt.Errorf("document retrieval not yet implemented in Diagon Phase 4")
}</span>

// DeleteDocument deletes a document (not yet implemented in Phase 4)
func (s *Shard) DeleteDocument(docID string) error <span class="cov0" title="0">{
        // TODO: Implement when document deletion is available in Diagon
        s.logger.Warn("Document deletion not yet implemented in Diagon Phase 4", zap.String("doc_id", docID))
        return fmt.Errorf("document deletion not yet implemented in Diagon Phase 4")
}</span>

// Close closes the shard and frees all resources
func (s *Shard) Close() error <span class="cov2" title="10">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Close searcher
        if s.searcher != nil </span><span class="cov2" title="5">{
                C.diagon_free_index_searcher(s.searcher)
                s.searcher = nil
        }</span>

        // Close reader
        <span class="cov2" title="10">if s.reader != nil </span><span class="cov2" title="5">{
                C.diagon_close_index_reader(s.reader)
                s.reader = nil
        }</span>

        // Close writer
        <span class="cov2" title="10">if s.writer != nil </span><span class="cov2" title="5">{
                C.diagon_close_index_writer(s.writer)
                s.writer = nil
        }</span>

        // Close directory
        <span class="cov2" title="10">if s.directory != nil </span><span class="cov2" title="5">{
                C.diagon_close_directory(s.directory)
                s.directory = nil
        }</span>

        <span class="cov2" title="10">s.logger.Info("Closed real Diagon shard")

        return nil</span>
}

// SearchResult represents search results
type SearchResult struct {
        Took         int64                        `json:"took"`
        TotalHits    int64                        `json:"total_hits"`
        MaxScore     float64                      `json:"max_score"`
        Hits         []*Hit                       `json:"hits"`
        Aggregations map[string]AggregationResult `json:"aggregations,omitempty"`
}

// Hit represents a search hit
type Hit struct {
        ID     string                 `json:"_id"`
        Score  float64                `json:"_score"`
        Source map[string]interface{} `json:"_source"`
}

// AggregationResult represents an aggregation result
type AggregationResult struct {
        Type    string                   `json:"type"`
        Buckets []map[string]interface{} `json:"buckets,omitempty"`
        Count   int64                    `json:"count,omitempty"`
        Min     float64                  `json:"min,omitempty"`
        Max     float64                  `json:"max,omitempty"`
        Avg     float64                  `json:"avg,omitempty"`
        Sum     float64                  `json:"sum,omitempty"`
        Value   int64                    `json:"value,omitempty"`
        Values  map[string]float64       `json:"values,omitempty"`
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
